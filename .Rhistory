usethis::use_gpl3_license()
library(usethis)
usethis::use_gpl3_license("Thomas Enzlein")
library(MALDIquant)
spec <- MALDIquant::createMassSpectrum(1:100, 1:100)
View(spec)
mass(spec)
intensity(spec)
load("C:/Users/tenzl/Desktop/benchmark_peakvstpoint.r")
m
library(tidyverse)
m %>% group_by(expr) %>% summarise(mean = mean(time/1e6), sd = sd (time/1e6))
library(microbenchmark)
print(m)
m %>% group_by(expr) %>% summarise(mean = mean(time/1e6), sd = sd (time/1e6))
m %>% group_by(expr) %>% summarise(mean = mean(time/1e8), sd = sd (time/1e8))
m %>% group_by(expr) %>% summarise(mean = mean(time/1e9), sd = sd (time/1e9))
cite(microbenchmark())
cite(microbenchmark)
cite("microbenchmark")
ii <- MALDIquant::msiSlices(NLGF67w_mouse1_rep1_spec,
center = c(4059.9,
4159.1,
4259,
4442.6),
tolerance = 5)
library(PlaquePicker)
ii <- MALDIquant::msiSlices(NLGF67w_mouse1_rep1_spec,
center = c(4059.9,
4159.1,
4259,
4442.6),
tolerance = 5)
pp <- plaquePicker(ii, coord = NLGF67w_mouse1_rep1_coord)
plot_venn(pp)
plot_venn(pp, mzIdx = 1:4)
#'
#' @param pp       plaquePicker result list
#' @param mzIdx    integer vector, indicies of mz values. To get an overview of mz values try \code{get_mzValues()}. Can not be longer then 3.
#' @param mzNames  character vector, names of mz values (e.g. "ABeta1-38"). If set to NULL (default) the mz values themself will be used as names during plotting.
#' @param plot     logical, if set to FALSE the \code{Venn} object is returned.
#' @param method   character, if set to "plaque" the Venn diagram will be based on overlapping signals per plaque. If set to "pixel" then it will be pixel-wise.
#' @param relative logical, if set to false the number of plaques is returned instead of the percentage.
#'
#'
#' @export
plot_venn <- function(pp, mzIdx = 1:3, mzNames =NULL, plot = TRUE, method = c("plaque", "pixel"), relative = TRUE) {
method = match.arg(method)
if(!requireNamespace("Vennerable")) {
stop("To use this function the package 'Vennerable' is needed.\n
Install it using devtools::install_github('js229/Vennerable').\n
Vennerable depends on 'graph' and 'RBGL' from Bioconductor!\n")
}
if(!is.null(mzNames)) {
if(!length(mzNames) == length(mzIdx)) {
stop("mzNames must be either NULL or same lenght as mzIdx\n")
}
}
# extract matrix of unified plaque IDs
unified <- pp$unified$uniComp
# get mzValues of IonImages
mzVal <- get_mzValues(pp)[mzIdx]
PlaqueIDs_venn <- vector("list",
length = length(mzIdx))
for(i in 1:length(mzIdx)) {
switch(method,
"plaque" = {
PlaqueIDs_venn[[i]] <- pp[[mzIdx[i]]]$binMat * unified
PlaqueIDs_venn[[i]] <- PlaqueIDs_venn[[i]] %>%
as.vector() %>%
unique() %>%
na.omit() %>%
sort() %>%
.[-1]
},
"pixel" = {
PlaqueIDs_venn[[i]] <- unlist(pp[[mzIdx[i]]]$spectraIdx)
})
}
if(!is.null(mzNames)) {
names(PlaqueIDs_venn) <- mzNames
} else {
names(PlaqueIDs_venn) <- mzVal
}
venn <- Vennerable::Venn(PlaqueIDs_venn)
if(relative) {
l <- length(mzIdx)+1
venn@IndicatorWeight[,l] <-
round(venn@IndicatorWeight[,l]/sum(venn@IndicatorWeight[,l]),3) * 100
}
if(!plot) {
return(venn)
}
plot(venn)
}
plot_venn(pp, mzIdx = 1:4)
library(tidyverse)
plot_venn(pp, mzIdx = 1:4)
#'
#' @param pp       plaquePicker result list
#' @param mzIdx    integer vector, indicies of mz values. To get an overview of mz values try \code{get_mzValues()}. Can not be longer then 3.
#' @param mzNames  character vector, names of mz values (e.g. "ABeta1-38"). If set to NULL (default) the mz values themself will be used as names during plotting.
#' @param plot     logical, if set to FALSE the \code{Venn} object is returned.
#' @param method   character, if set to "plaque" the Venn diagram will be based on overlapping signals per plaque. If set to "pixel" then it will be pixel-wise.
#' @param relative logical, if set to false the number of plaques is returned instead of the percentage.
#'
#'
#' @export
plot_venn <- function(pp, mzIdx = 1:3, mzNames =NULL, plot = TRUE, method = c("plaque", "pixel"), relative = TRUE) {
method = match.arg(method)
if(!requireNamespace("Vennerable")) {
stop("To use this function the package 'Vennerable' is needed.\n
Install it using devtools::install_github('js229/Vennerable').\n
Vennerable depends on 'graph' and 'RBGL' from Bioconductor!\n")
}
if(!is.null(mzNames)) {
if(!length(mzNames) == length(mzIdx)) {
stop("mzNames must be either NULL or same lenght as mzIdx\n")
}
}
# extract matrix of unified plaque IDs
unified <- pp$unified$uniComp
# get mzValues of IonImages
mzVal <- get_mzValues(pp)[mzIdx]
PlaqueIDs_venn <- vector("list",
length = length(mzIdx))
for(i in 1:length(mzIdx)) {
switch(method,
"plaque" = {
PlaqueIDs_venn[[i]] <- pp[[mzIdx[i]]]$binMat * unified
PlaqueIDs_venn[[i]] <- PlaqueIDs_venn[[i]] %>%
as.vector() %>%
unique() %>%
na.omit() %>%
sort() %>%
.[-1]
},
"pixel" = {
PlaqueIDs_venn[[i]] <- unlist(pp[[mzIdx[i]]]$spectraIdx)
})
}
if(!is.null(mzNames)) {
names(PlaqueIDs_venn) <- mzNames
} else {
names(PlaqueIDs_venn) <- mzVal
}
venn <- Vennerable::Venn(PlaqueIDs_venn)
if(relative) {
l <- length(mzIdx)+1
venn@IndicatorWeight[,l] <-
round(venn@IndicatorWeight[,l]/sum(venn@IndicatorWeight[,l]),3) * 100
}
if(!plot) {
return(venn)
}
Vennerable::plot(venn)
}
plot_venn(pp, mzIdx = 1:4)
a <- plot_venn(pp, mzIdx = 1:4, plot = F)
plot(a)
Vennerable:::plotVenn(a)
Vennerable::compute.Venn(a)
Vennerable::compute.Venn(a, type = "AWFE")
Vennerable::compute.Venn(a, type = "ChowRuskey")
Vennerable:::compute.S4(a)
plot(Vennerable:::compute.S4(a))
Vennerable::plot(Vennerable:::compute.S4(a))
#'
#' @param pp       plaquePicker result list
#' @param mzIdx    integer vector, indicies of mz values. To get an overview of mz values try \code{get_mzValues()}. Can not be longer then 3.
#' @param mzNames  character vector, names of mz values (e.g. "ABeta1-38"). If set to NULL (default) the mz values themself will be used as names during plotting.
#' @param plot     logical, if set to FALSE the \code{Venn} object is returned.
#' @param method   character, if set to "plaque" the Venn diagram will be based on overlapping signals per plaque. If set to "pixel" then it will be pixel-wise.
#' @param relative logical, if set to false the number of plaques is returned instead of the percentage.
#'
#'
#' @export
plot_venn <- function(pp, mzIdx = 1:3, mzNames =NULL, plot = TRUE, method = c("plaque", "pixel"), relative = TRUE) {
method = match.arg(method)
if(!requireNamespace("Vennerable")) {
stop("To use this function the package 'Vennerable' is needed.\n
Install it using devtools::install_github('js229/Vennerable').\n
Vennerable depends on 'graph' and 'RBGL' from Bioconductor!\n")
}
if(!is.null(mzNames)) {
if(!length(mzNames) == length(mzIdx)) {
stop("mzNames must be either NULL or same lenght as mzIdx\n")
}
}
# extract matrix of unified plaque IDs
unified <- pp$unified$uniComp
# get mzValues of IonImages
mzVal <- get_mzValues(pp)[mzIdx]
PlaqueIDs_venn <- vector("list",
length = length(mzIdx))
for(i in 1:length(mzIdx)) {
switch(method,
"plaque" = {
PlaqueIDs_venn[[i]] <- pp[[mzIdx[i]]]$binMat * unified
PlaqueIDs_venn[[i]] <- PlaqueIDs_venn[[i]] %>%
as.vector() %>%
unique() %>%
na.omit() %>%
sort() %>%
.[-1]
},
"pixel" = {
PlaqueIDs_venn[[i]] <- unlist(pp[[mzIdx[i]]]$spectraIdx)
})
}
if(!is.null(mzNames)) {
names(PlaqueIDs_venn) <- mzNames
} else {
names(PlaqueIDs_venn) <- mzVal
}
venn <- Vennerable::Venn(PlaqueIDs_venn)
if(relative) {
l <- length(mzIdx)+1
venn@IndicatorWeight[,l] <-
round(venn@IndicatorWeight[,l]/sum(venn@IndicatorWeight[,l]),3) * 100
}
if(!plot) {
return(venn)
}
if(length(mzIdx) < 4) {
Vennerable::plot(venn)
} else {
Vennerable::plot(Vennerable:::compute.S4(venn))
}
}
library(PlaquePicker)
plot_venn(pp)
plot_venn(pp, mzIdx = 1:4)
View(pp)
pp$4259$binMat %>% image(., asp = 1)
pp$'4259'$binMat %>% image(., asp = 1)
pp$4059.9$binMat %>% image(., asp = 1)
pp$'4059.9'$binMat %>% image(., asp = 1)
image(ii[,,1], asp= TRUE)
hist(ii[,,1])
hist(ii[,,1], breaks = 300)
tpoint(ii[,,1])
plot_venn(pp)
plot_venn(pp)
plot_venn(pp, mzIdx = 1:4)
