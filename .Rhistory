},
"pixel" = {
PlaqueIDs_venn[[i]] <- unlist(pp[[mzIdx[i]]]$spectraIdx)
})
}
if(!is.null(mzNames)) {
names(PlaqueIDs_venn) <- mzNames
} else {
names(PlaqueIDs_venn) <- mzVal
}
venn <- Vennerable::Venn(PlaqueIDs_venn)
if(relative) {
l <- length(mzIdx)+1
venn@IndicatorWeight[,l] <-
round(venn@IndicatorWeight[,l]/sum(venn@IndicatorWeight[,l]),3) * 100
}
if(!plot) {
return(venn)
}
if(length(mzIdx) < 4) {
Vennerable::plot(venn)
} else {
Vennerable::plot(Vennerable:::compute.S4(venn))
}
}
library(PlaquePicker)
plot_venn(pp)
plot_venn(pp, mzIdx = 1:4)
View(pp)
pp$4259$binMat %>% image(., asp = 1)
pp$'4259'$binMat %>% image(., asp = 1)
pp$4059.9$binMat %>% image(., asp = 1)
pp$'4059.9'$binMat %>% image(., asp = 1)
image(ii[,,1], asp= TRUE)
hist(ii[,,1])
hist(ii[,,1], breaks = 300)
tpoint(ii[,,1])
plot_venn(pp)
plot_venn(pp)
plot_venn(pp, mzIdx = 1:4)
gi
devtools::document()
sessionInfo()
devtools::document()
renv::activate()
knitr::opts_chunk$set(dpi=600,fig.width=8)
install.packages("knitr")
install.packages("evaluate")
install.packages("knitr", dependencies = TRUE)
knitr::opts_chunk$set(dpi=600,fig.width=8)
install.packages("MALDIquant", dependencies = TRUE)
install.packages("MALDIquantForeign", dependencies = TRUE)
# install devtools to be able to install packages from github
install.packages("devtools", dependencies = TRUE)
devtools::install_github("CeMOS-Mannheim/plaquePicker")
# The following dependencies are not needed to use the core functions of the package
# but will be used in this vignette
install.packages("tidyverse", dependencies = TRUE)
# The following dependencies are not needed to use the core functions of the package
# but will be used in this vignette
install.packages("tidyverse", dependencies = TRUE)
install.packages("viridis", dependencies = TRUE)
# for the plotting of Venn-Diagrams we will be using the package Vennerable
# which is not in the CRAN repository and has some dependencies to the
# BioConductor repository.
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
BiocManager::install("RBGL")
BiocManager::install("graph")
devtools::install_github("js229/Vennerable")
devtools::install_github("js229/Vennerable", dependencies = TRUE)
install.packages("RColorBrewer")
install.packages("RColorBrewer")
devtools::install_github("js229/Vennerable", dependencies = TRUE)
renv::hydrate()
renv::clean()
renv::hydrate()
renv::deactivate()
renv::activate()
knitr::opts_chunk$set(dpi=600,fig.width=8)
install.packages("MALDIquant", dependencies = TRUE)
install.packages("MALDIquant", dependencies = TRUE)
install.packages("MALDIquantForeign", dependencies = TRUE)
# install devtools to be able to install packages from github
install.packages("devtools", dependencies = TRUE)
#devtools::install_github("CeMOS-Mannheim/plaquePicker")
# The following dependencies are not needed to use the core functions of the package
# but will be used in this vignette
install.packages("tidyverse", dependencies = TRUE)
install.packages("viridis", dependencies = TRUE)
# for the plotting of Venn-Diagrams we will be using the package Vennerable
# which is not in the CRAN repository and has some dependencies to the
# BioConductor repository.
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.11")
BiocManager::install("RBGL")
BiocManager::install("graph")
install.packages("RColorBrewer", dependencies = TRUE)
devtools::install_github("js229/Vennerable", dependencies = TRUE)
install.packages("backports")
install.packages("backports")
install.packages("backports")
install.packages("backports", force = TRUE
)
devtools::install_github("js229/Vennerable", dependencies = TRUE)
devtools::document()
rlang::last_error()
install.packages("igraph")
install.packages("igraph", dependencies = TRUE)
devtools::document()
devtools::build_vignettes()
devtools::document()
library(PlaquePicker)
require(MALDIquant)
a <- require(MALDIquant)
a
devtools::install_github("js229/Vennerable")
install.packages("C:/Users/tenzl/Downloads/Vennerable-master.zip", repos = NULL, type = "win.binary")
library(`Vennerable-master`)
devtools::install_github("js229/Vennerable", dependencies = TRUE)
devtools::install_github("js229/Vennerable", force = TRUE)
devtools::install_github("js229/Vennerable", ref = "Master",)
devtools::install_github("js229/Vennerable", ref = "master",)
devtools::install_github("js229/Vennerable")
remove.packages(Vennerable)
remove.packages("Vennerable")
.rs.restartR()
devtools::install_github("js229/Vennerable")
devtools::install_github("js229/Vennerable", build = FALSE)
library(devtools)
install_github("js229/Vennerable")
update.packages(ask = FALSE, checkBuilt = TRUE)
update.packages(ask = FALSE, checkBuilt = TRUE)
devtools::install_github("js229/Vennerable")
source('Y:/1-DrArbeitPhD/1 - phd/32-Thomas Enzlein/smuge_mousemodels_series/R/PlaquePicker0.1/PlaquePicker/R/plaquePicker.R')
plaquePicker(NLGF67w_mouse1_rep1, coord = NLGF67w_mouse1_rep1_coord)
library(PlaquePicker)
source('Y:/1-DrArbeitPhD/1 - phd/32-Thomas Enzlein/smuge_mousemodels_series/R/PlaquePicker0.1/PlaquePicker/R/plaquePicker.R')
plaquePicker(NLGF67w_mouse1_rep1, coord = NLGF67w_mouse1_rep1_coord)
source('Y:/1-DrArbeitPhD/1 - phd/32-Thomas Enzlein/smuge_mousemodels_series/R/PlaquePicker0.1/PlaquePicker/R/plaquePicker.R')
plaquePicker(NLGF67w_mouse1_rep1, coord = NLGF67w_mouse1_rep1_coord)
vignette(package ="PlaquePicker")
library(tidyr)
library(Vennerable)
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager", repos = "http://cran.us.r-project.org")
BiocManager::install(version = "3.11")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager", repos = "http://cran.us.r-project.org")
BiocManager::install(version = "3.11")
if (!requireNamespace("BiocManager", quietly = TRUE))
install.packages("BiocManager", repos = "http://cran.us.r-project.org")
BiocManager::install(version = "3.11")
if(!require(Vennerable))
devtools::install_github("js229/Vennerable")
BiocManager::install("graph")
devtools::install_github("js229/Vennerable")
devtools::install_github("js229/Vennerable")
renv::deactivate()
library(Vennerable)
Vennerable::plot()
library(PlaquePicker)
usethis::use_mit_license()
usethis::use_mit_license("Thomas Enzlein")
## -----------------------------------------------------------------------------
suppressPackageStartupMessages({
library(PlaquePicker)
library(MALDIquant)        # general MS functions
library(MALDIquantForeign) # for import of imzML data
library(tidyverse)         # general data science tools
library(viridis)           # pretty colors for ion images
# for the plotting of Venn-Diagrams we will be using the package Vennerable
# which is not in the CRAN repository and has some dependencies to the
# BioConductor repository. To install Vennerable and its dependencies
# use the following commands:
#
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install(version = "3.11")
# BiocManager::install("RBGL")
# BiocManager::install("graph")
# devtools::install_github("js229/Vennerable")
library(Vennerable)})
## ---- eval = TRUE, results='hide'---------------------------------------------
# unzip spectra
unzip("data-raw/NLGF67w_mouse1_rep1.zip")
# read spectra
spec <- importImzMl("NLGF_Prot_NLGF1.imzML",
verbose = FALSE)
## -----------------------------------------------------------------------------
ionImages <- msiSlices(spec,
center = c(4059.9,
4159.1,
4442.6),
tolerance = 5)
## ---- warning=FALSE-----------------------------------------------------------
coord <- coordinates(spec)
pp <- plaquePicker(ionImages = ionImages,
coord = coord,
method = "tpoint")
thresh_Ab38 <- tpoint(ionImages[,,1], plot = TRUE)
## -----------------------------------------------------------------------------
bin <- ifelse(test = thresh_Ab38 < as.vector(ionImages[,,1]),
yes = 1,
no = ifelse(is.na(as.vector(ionImages[,,1])),
yes = NA,
no = 0))
pp <- plaquePicker(ionImages = ionImages,
binMatrix = bin,
coord = coord,
method = "tpoint")
dim(bin)
# rebuild the matrix
binMat <- matrix(bin,
nrow = dim(ionImages[,,1])[1],
ncol = dim(ionImages[,,1])[2])
pp <- plaquePicker(ionImages = ionImages,
binMatrix = binMat,
coord = coord,
method = "tpoint")
pp <- plaquePicker(ionImages = ionImages,
binMatrix = binMat,
coord = coord,
method = "tpoint")
View(pp)
dim(ionImages)
ii2 <- array(c(ionImages, ionImages))
dim(ii2)
ii2 <- array(c(ionImages, ionImages), dim = c(dim(ionImages)[c(1,2)], dim(ionImages)[3]*2))
dim(ii2)
image(ii2[,,3])
image(ii2[,,1])
image(ii2[,,4])
image(ii2[,,6])
#'     \code{threshold}    numeric, the threshold estimated by \code{tpoint}-function.
#'     \code{spectraIdx}   list of integer vectors containing the indecies of the spectra in the list of \code{MALDIquant::massObject}.
#' Also, there is another entry called \code{unified}: The result of all binarized ion images combined.
#'     In addition to \code{conComp}, \code{binMat}, and \code{spectraIdx} that contain the equivalent matrices of the unified data as described above this entry contains the following:
#'     \code{intensities}  list of lists containing the intensities of the corresponding pixels for the provided ion images
#'
#' @export
#'
#' @examples
#' pp <- plaquePicker(NLGF67w_mouse1_rep1, coord = NLGF67w_mouse1_rep1_coord)
plaquePicker <- function(ionImages, coord, method = c("tpoint", "geometric", "peak"), binMatrix = NULL, addIonImages = NULL, ...) {
if(!is.null(binMatrix)) {
# check if dimof ionImages and binMatrix match. Otherwise stop.
if(!dim(ionImages[,,1])[1] == dim(binMatrix)[1] & !dim(ionImages[,,1])[2] == dim(binMatrix)[2]) {
stop("Dimensions of binMatrix has to be the same as ionImages! \n
!dim(ionImages[,,1]) == dim(binMatrix)\n")
}
method <- "binMat"
} else {
method <- match.arg(method)
}
if(!is.null(addIonImages)) {
# check if dim of ionImages and addIonImages match. Otherwise stop.
if(!dim(ionImages[,,1])[1] == dim(addIonImages)[1] & !dim(ionImages[,,1])[2] == dim(addIonImages)[2]) {
stop("Dimensions of addIonImages has to be the same as ionImages! \n
!dim(ionImages[,,1]) == dim(addIonImages)\n")
}
}
mzValues <- attr(ionImages, "center")
resultList <- vector("list", length = length(mzValues)+1)
# empty matrix for storage of unified binary image
uni <- matrix(data = 0, nrow = dim(ionImages[,,1])[1],
ncol = dim(ionImages[,,1])[2])
# name cols and rows of uni
# according to the original coordinate system in MALDIQuant object
rownames(uni) <- sort(unique(coord[,1])) # x
colnames(uni) <- sort(unique(coord[,2])) # y
for(i in 1:length(mzValues)) {
cat("processing", mzValues[i], i , "/", length(mzValues) ,"\n")
# get threshold and perform binarization
ints <- as.vector(ionImages[,,i])
switch(method,
"tpoint" = {
threshold <- tpoint(ints, ...)
cat("\n threshold of mz", mzValues[i],"based on t-point thresholding = ", threshold, "\n")
bin <- ifelse(test = threshold < ints,
yes = 1,
no = ifelse(is.na(ints),
yes = NA,
no = 0))
},
"geometric" = {
threshold <- geometricThreshold(ints, ...)
cat("\n threshold of mz", mzValues[i],"based on geometric thresholding = ", threshold, "\n")
bin <- ifelse(test = threshold < ints,
yes = 1,
no = ifelse(is.na(ints),
yes = NA,
no = 0))
},
"peak" = {
cat("\n no threshold needed for mz", mzValues[i],"data considered as peaks\n")
bin <- ifelse(test = ints > 0,
yes = 1,
no = ifelse(is.na(ints),
yes = NA,
no = 0))
threshold <- -Inf
},
"binMat" = {
cat("\n no threshold needed for mz", mzValues[i],"binMatrix used for segmentation\n")
bin <- binMatrix
threshold <- -Inf
}
)
# rebuild the matrix
binMat <- matrix(bin,
nrow = dim(ionImages[,,i])[1],
ncol = dim(ionImages[,,i])[2])
# perfrom connceted component labeling
conComp <- raster::as.matrix(raster::clump(raster::raster(binMat),
direction = 8))
# name cols and rows of conComp
# according to the original coordinate system in MALDIQuant object
rownames(conComp) <- sort(unique(coord[,1])) # x
colnames(conComp) <- sort(unique(coord[,2])) # y
resultList[[i]][["conComp"]] <- conComp
resultList[[i]][["binMat"]] <- binMat
resultList[[i]][["threshold"]] <- threshold
cat("extracting clump information...\n")
resultList[[i]][["spectraIdx"]] <- get_specIdx(comp = conComp, coord = coord)
# add binMat to unified binary image
uni <- uni + binMat
uni[uni > 0] <- 1
}
resultList[[length(resultList)]][["uniBin"]] <- uni
uniComp <- raster::as.matrix(raster::clump(raster::raster(uni),
direction = 8))
# name cols and rows of uniComp
rownames(uniComp) <- rownames(uni)
colnames(uniComp) <- colnames(uni)
resultList[[length(resultList)]][["uniComp"]] <- uniComp
cat("extracting unified clump information...\n")
resultList[[length(resultList)]][["spectraIdx"]] <- get_specIdx(comp = uniComp, coord = coord)
names(resultList) <- c(mzValues, "unified")
if(!is.null(addIonImages)) {
} else {
d <- dim(ionImages)
allIonImages <- array(data = c(ionImages, addIonImages), dim = c(d[1:2], d[3]*2))
resultList[[length(resultList)]][["intensities"]] <- get_intensities(comp = uniComp, ii = allIonImages)
}
return(resultList)
}
pp <- plaquePicker(ionImages = ionImages,
addIonImages = ionImages[,,1],
coord = coord,
method = "tpoint")
source('W:/1-DrArbeitPhD/1 - phd/32-Thomas Enzlein/Paper contributions/Enzlein 2020/mousemodels_series/R/PlaquePicker0.1/PlaquePicker/R/plaquePicker.R', echo=TRUE)
pp <- plaquePicker(ionImages = ionImages,
addIonImages = ionImages[,,1],
coord = coord,
method = "tpoint")
View(pp)
#'     \code{threshold}    numeric, the threshold estimated by \code{tpoint}-function.
#'     \code{spectraIdx}   list of integer vectors containing the indecies of the spectra in the list of \code{MALDIquant::massObject}.
#' Also, there is another entry called \code{unified}: The result of all binarized ion images combined.
#'     In addition to \code{conComp}, \code{binMat}, and \code{spectraIdx} that contain the equivalent matrices of the unified data as described above this entry contains the following:
#'     \code{intensities}  list of lists containing the intensities of the corresponding pixels for the provided ion images
#'
#' @export
#'
#' @examples
#' pp <- plaquePicker(NLGF67w_mouse1_rep1, coord = NLGF67w_mouse1_rep1_coord)
plaquePicker <- function(ionImages, coord, method = c("tpoint", "geometric", "peak"), binMatrix = NULL, addIonImages = NULL, ...) {
if(!is.null(binMatrix)) {
# check if dimof ionImages and binMatrix match. Otherwise stop.
if(!dim(ionImages[,,1])[1] == dim(binMatrix)[1] & !dim(ionImages[,,1])[2] == dim(binMatrix)[2]) {
stop("Dimensions of binMatrix has to be the same as ionImages! \n
!dim(ionImages[,,1]) == dim(binMatrix)\n")
}
method <- "binMat"
} else {
method <- match.arg(method)
}
if(!is.null(addIonImages)) {
# check if dim of ionImages and addIonImages match. Otherwise stop.
if(!dim(ionImages[,,1])[1] == dim(addIonImages)[1] & !dim(ionImages[,,1])[2] == dim(addIonImages)[2]) {
stop("Dimensions of addIonImages has to be the same as ionImages! \n
!dim(ionImages[,,1]) == dim(addIonImages)\n")
}
}
mzValues <- attr(ionImages, "center")
resultList <- vector("list", length = length(mzValues)+1)
# empty matrix for storage of unified binary image
uni <- matrix(data = 0, nrow = dim(ionImages[,,1])[1],
ncol = dim(ionImages[,,1])[2])
# name cols and rows of uni
# according to the original coordinate system in MALDIQuant object
rownames(uni) <- sort(unique(coord[,1])) # x
colnames(uni) <- sort(unique(coord[,2])) # y
for(i in 1:length(mzValues)) {
cat("processing", mzValues[i], i , "/", length(mzValues) ,"\n")
# get threshold and perform binarization
ints <- as.vector(ionImages[,,i])
switch(method,
"tpoint" = {
threshold <- tpoint(ints, ...)
cat("\n threshold of mz", mzValues[i],"based on t-point thresholding = ", threshold, "\n")
bin <- ifelse(test = threshold < ints,
yes = 1,
no = ifelse(is.na(ints),
yes = NA,
no = 0))
},
"geometric" = {
threshold <- geometricThreshold(ints, ...)
cat("\n threshold of mz", mzValues[i],"based on geometric thresholding = ", threshold, "\n")
bin <- ifelse(test = threshold < ints,
yes = 1,
no = ifelse(is.na(ints),
yes = NA,
no = 0))
},
"peak" = {
cat("\n no threshold needed for mz", mzValues[i],"data considered as peaks\n")
bin <- ifelse(test = ints > 0,
yes = 1,
no = ifelse(is.na(ints),
yes = NA,
no = 0))
threshold <- -Inf
},
"binMat" = {
cat("\n no threshold needed for mz", mzValues[i],"binMatrix used for segmentation\n")
bin <- binMatrix
threshold <- -Inf
}
)
# rebuild the matrix
binMat <- matrix(bin,
nrow = dim(ionImages[,,i])[1],
ncol = dim(ionImages[,,i])[2])
# perfrom connceted component labeling
conComp <- raster::as.matrix(raster::clump(raster::raster(binMat),
direction = 8))
# name cols and rows of conComp
# according to the original coordinate system in MALDIQuant object
rownames(conComp) <- sort(unique(coord[,1])) # x
colnames(conComp) <- sort(unique(coord[,2])) # y
resultList[[i]][["conComp"]] <- conComp
resultList[[i]][["binMat"]] <- binMat
resultList[[i]][["threshold"]] <- threshold
cat("extracting clump information...\n")
resultList[[i]][["spectraIdx"]] <- get_specIdx(comp = conComp, coord = coord)
# add binMat to unified binary image
uni <- uni + binMat
uni[uni > 0] <- 1
}
resultList[[length(resultList)]][["uniBin"]] <- uni
uniComp <- raster::as.matrix(raster::clump(raster::raster(uni),
direction = 8))
# name cols and rows of uniComp
rownames(uniComp) <- rownames(uni)
colnames(uniComp) <- colnames(uni)
resultList[[length(resultList)]][["uniComp"]] <- uniComp
cat("extracting unified clump information...\n")
resultList[[length(resultList)]][["spectraIdx"]] <- get_specIdx(comp = uniComp, coord = coord)
names(resultList) <- c(mzValues, "unified")
if(!is.null(addIonImages)) {
d <- dim(ionImages)
allIonImages <- array(data = c(ionImages, addIonImages), dim = c(d[1:2], d[3]*2))
resultList[[length(resultList)]][["intensities"]] <- get_intensities(comp = uniComp, ii = allIonImages)
} else {
resultList[[length(resultList)]][["intensities"]] <- get_intensities(comp = uniComp, ii = ionImages)
}
return(resultList)
}
pp <- plaquePicker(ionImages = ionImages,
addIonImages = ionImages[,,1],
coord = coord,
method = "tpoint")
debugonce(get_intensities)
pp <- plaquePicker(ionImages = ionImages,
addIonImages = ionImages[,,1],
coord = coord,
method = "tpoint")
source('W:/1-DrArbeitPhD/1 - phd/32-Thomas Enzlein/Paper contributions/Enzlein 2020/mousemodels_series/R/PlaquePicker0.1/PlaquePicker/R/plaquePicker.R', echo=TRUE)
pp <- plaquePicker(ionImages = ionImages,
addIonImages = ionImages[,,1],
coord = coord,
method = "tpoint")
View(pp)
debugonce(get_intensities)
pp <- plaquePicker(ionImages = ionImages,
addIonImages = ionImages[,,1],
coord = coord,
method = "tpoint")
d <- dim(ionImages)
allIonImages <- array(data = c(ionImages, ionImages[,,1]), dim = c(d[1:2], d[3]*2))
attr(allIonImages, "center")
attr(ionImages, "center")
attr(ionImages[,,1], "center")
add <- ionImages[,,1:2]
attr(add, "center") <- attr(ionImages, "center")[1:2]
attr(add, "center")
pp <- plaquePicker(ionImages = ionImages,
addIonImages = add,
coord = coord,
method = "tpoint")
View(pp)
View(pp)
file.remove("NLGF_Prot_NLGF1.imzML")
file.remove("NLGF_Prot_NLGF1.ibd")
library(PlaquePicker)
library(PlaquePicker)
library(PlaquePicker)
