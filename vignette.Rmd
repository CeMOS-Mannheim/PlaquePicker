---
title: "PLAQUE PICKER Example"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(dpi=600,fig.width=8)
```

Load needed libraries
```{r, echo=FALSE}
suppressPackageStartupMessages({
  library(PlaquePicker)
  library(MALDIquant)        # general MS functions
  library(MALDIquantForeign) # for import of imzML data
  library(tidyverse)         # general data science tools
  library(viridis)           # pretty colors for ion images
  
  # for the plotting of Venn-Diagrams we will be using the package Vennerable 
  # which is not in the CRAN repository and has some dependencies to the 
  # BioConductor repository. To install Vennerable and its dependencies 
  # use the following commands:
  #
  # if (!requireNamespace("BiocManager", quietly = TRUE))
  #     install.packages("BiocManager")
  # BiocManager::install(version = "3.11")
  # BiocManager::install("RBGL")
  # BiocManager::install("graph")
  # devtools::install_github("js229/Vennerable")
  library(Vennerable)})
```

This package comes with a preprared set of ion images that can directly be used by the plaquePicker-function. Nevertheless, here we show how we prepared this example data: 
```{r, eval = TRUE, echo=FALSE}
# unzip spectra
unzip("data-raw/NLGF67w_mouse1_rep1.zip")

# read spectra
spec <- importImzMl("NLGF_Prot_NLGF1.imzML",
                    verbose = FALSE)

# tidy up
file.remove("NLGF_Prot_NLGF1.imzML")
file.remove("NLGF_Prot_NLGF1.ibd")

```

Preprocess spectra using MALDIquant functions: Normalize, smooth, remove baseline. Compute average spectrum and plot it to get an overview of the dataset. 
```{r, warning=FALSE, eval=FALSE}
spec <- calibrateIntensity(spec,
                           method = "TIC")

# small halfWindowSize needed as number of points 
# per spectra reduced for smaller example datasets
spec <- smoothIntensity(spec,
                        method = "SavitzkyGolay",
                        halfWindowSize = 2) 

spec <- removeBaseline(spec,
                       method = "TopHat")


```

```{r}
avgSpec <- averageMassSpectra(spec)

# shorten filepath (for plotting reasons only)
avgSpec@metaData$file <- basename(avgSpec@metaData$file)

plot(avgSpec, ylab = "Intensity [a.u.]")
lines(detectPeaks(avgSpec))
labelPeaks(detectPeaks(avgSpec), 
           digits = 0)
```

We observe a strong peak at m/z 4059 (Ab1-38Arc), and two smaller peaks at m/z 4159 (Ab1-39Arc) and 4442 (Ab1-42Arc). Note that as we computed the average spectrum for all spectra and the Abeta signals are only found in a small subset of spectra,this leads to underrepesentation of the signals in the average spectrum. Also, because of the lower resolution of the example data set, the peak maxima shifted slightly in comparision to those reported in the publication.

Next we extract ion images of interest.
```{r}
ionImages <- msiSlices(spec, 
                       center = c(4059,
                                  4160,
                                  4442),
                       tolerance = 5)
```


When we take a look at these ion images we can observe distinct accumulations of Abeta as plaques. Ab1-38Arc and Ab1-39Arc are highly co-localized wheras Ab1-42Arc seems to also accumulate at other locations then the other two masses. Note that we applied quantile correction to the 99.95%-quantile to remove hotspots for better visualization. As mentioned above, the signals of interest are only found in a small subset of spectra (-> sparse-signals).
```{r}
par(mfrow = c(1, 3), mar =c(0,0,0,0))
image(qcor(ionImages[,,1], 0.9995), 
      col = viridis::cividis(30), 
      asp = 1, 
      axes = FALSE)
title("Ab1-38Arc", line = -2)
image(qcor(ionImages[,,2], 0.9995), 
      col = viridis::cividis(30), 
      asp = 1, 
      axes = FALSE)
title("Ab1-39Arc", line = -2)
image(qcor(ionImages[,,3], 0.9995), 
      col = viridis::cividis(30), 
      asp = 1, 
      axes = FALSE)
title("Ab1-42Arc", line = -2)
```

Next we take a look at the histogram of intensities for Ab1-38Arc.
We observe a unimodal distribution. Most of the pixels have a intensity at the level of noise and there are only a few above that.
We use the tpoint method to find a threshold. This method fits to lines to the histogram, one for the ascending and one for the decending part. Both will of course have error. The intensity value where the sum of this two error is the lowest will be defined as threshold (see second plot).
For more information check Coudray, Nicolas; Buessler, Urban (2010). "Robust threshold estimation for images with unimodal histograms". Pattern Recognition Letters. 31 (9): 1010–1019. doi:10.1016/j.patrec.2009
```{r}
hist(ionImages[,,1], 
     breaks = 300,
     xlab = "Intensity [a.u.]", 
     main = "Histogram of Ab1-38Arc intensity")
thresh_Ab38 <- tpoint(ionImages[,,1], plot = TRUE)
```
If we apply this threshold to the corresponding ion image we get a binized image.
```{r}
bin <- ifelse(test = thresh_Ab38 < as.vector(ionImages[,,1]),
              yes = 1,
              no = ifelse(is.na(as.vector(ionImages[,,1])),
                          yes = NA,
                          no = 0))
# rebuild the matrix
binMat <- matrix(bin,
                 nrow = dim(ionImages[,,1])[1],
                 ncol = dim(ionImages[,,1])[2])
par(mfrow = c(1, 2), mar = c(0,0,0,0))
image(qcor(ionImages[,,1], 0.9999), 
      col = viridis::cividis(30), 
      asp = 1, 
      axes = FALSE)
title("Ab1-38Arc intensities", line = -1)
image(binMat, 
      col = c("black", "white"), 
      asp = 1, 
      axes = FALSE)
title("Ab1-38Arc binarized", line = -1)
```
Using this image we could apply raster::clump to perform connected component labeling and assign each individual plaque an ID. Or we could first compute the binary pictures of all ion images of interest, combine them and then apply connected component labeling.
Following the same principle as shown above we now apply the plaquePicker-function to the ion images. In additon to the ion images this function also needs the coordinates of the dataset so we have to also extract them.
Note that there are two other thresholding methods implemented. If you do not wish to apply any thresholding but rather use an ion image of data that was alread peak picked set method to "peak". Now each pixel with a intensity > 0 ("signal-bearing-pixel") will be considered for the following processing.
```{r, warning=FALSE}
coord <- coordinates(spec)
pp <- plaquePicker(ionImages = ionImages, 
                   coord = coord,
                   method = "tpoint")
```
Now that we have the dataset structed in a way suitable for single-object analysis we can perform some basic tasks. For example, lets take all spectra assosiated with Abeta signals and caluclate an average spectrum of plaques and compare it to the average spectrum of the whole dataset we computed above. We see that as dissused above, the Abeta signals were underrepresented in the orginal average spectrum as they only appear in a small number of the total pixels.
```{r, echo=FALSE}
# first extract the MALDIquant indicies assosiated with plaque
idx <- get_IdxFromID(pp, ID = NA) # setting ID to NA will extract all IDs instead of specific IDs

# compute average spectrum of plaque assosiated pixels
plaqueAvg <- averageMassSpectra(spec[idx]) 

# shorten filepath (for plotting reasons only)
plaqueAvg@metaData$file <- basename(plaqueAvg@metaData$file)

plot(plaqueAvg, 
     ylab = "Intensity [a.u.]")
lines(avgSpec, 
      lty=2)
labelPeaks(detectPeaks(plaqueAvg), 
           digits = 0)
lines(detectPeaks(plaqueAvg))
legend("right",
       legend=c("Plaque avg. spectrum","Overall avg. spectrum"),
       lty=1:2, 
       cex=0.8)
```

In addition to the unified results, the pp object has an entry containing the spectra indices of each individual object. 
Using the unified connected component labeled matrix (uniComp) in conjunction with the binary images for each ion image of interest we extract the plaques that co-localize with each other. This enables us to assess the plaques regarding their composition.

```{r}
plot_venn(pp, mzNames = c("Ab1-38Arc",
                          "Ab1-39Arc",
                          "Ab1-42Arc"),
          relative = FALSE)

```
We can use this data to analysis the general qualitative composition of plaques using a venn diagramm. 
Now we can quantify the visual impression we had when we took a look at the ion images above: Ab1-38Arc and Ab1-39Arc are highly co-localized but there is also a large number of plaques composed only of Ab1-38Arc. Also for Ab1-42 we find a large population that is only composed of Ab1-42Arc. Instead of using the number of plaques as labels we could also use relative values. 
Futhermore we could also check the pixelwise co-localization. Here we see the most of the pixels are assosiated with Ab1-38Arc only.
```{r}
plot_venn(pp, mzNames = c("Ab1-38Arc",
                          "Ab1-39Arc",
                          "Ab1-42Arc"),
          relative = TRUE, 
          method = "pixel")
```
As a next step lets look at the size distribution of the plaques. We recorded the MSI dataset with a pixel-size of 20x20 micrometer (um) which results in a pixel-area of 400 um².
The list "unified" in the pp object contains an entry "intensities" here we find a list for each plaque ID that contains all the intensities for the different mz values. The length of these vectors is equal to the number of pixels per plaque. First we transform this list structure to tibble for better usability.

```{r}
df <-bind_rows(pp$unified$intensities, .id = "ID") %>%
      group_by(ID) %>%
      mutate(size = n() * 400) 
head(df)
```
Using this tibble we first plot the histogram for the size distribution.
We find that most plaques are small but there are also some plaques that are really big. 
```{r}
ggplot(df, aes(x = size)) + 
  geom_histogram(bins = 50) + 
  theme_bw() +
  labs(x = "Plaque area [um²]")

```
Next we define some size-groups and see if there is anything we can learn regarding molecular composition of different plaque sizes.
As we see from the histogram most plaques are well below 10000 um² and as we want to have comparable group sizes we have to set the group bounaries according to that. We will define everything <= 400 um² (which means 1 pixel only) as "small", <= 2000 um² as "medium" and > 2000 um² as "big".
```{r}
df_size <- df %>%
  group_by(ID) %>%
  mutate(sizeGroup = ifelse(size <= 400, "small",
                            ifelse(size <= 2000, "medium", "big")))
df_size %>% group_by(sizeGroup) %>% summarise(n = length(unique(ID)))

```
Next we plot the Ab1-42Arc vs Ab1-38Arc ratio against the group size.
As we see the smaller plaques have a much higher median ratio (meaning more Ab1-42Arc in relation to Ab1-38Arc) then the big ones.
```{r}
df_size %>%
  ungroup() %>%
  rename("Ab1_38Arc" = "4059.9",
         "Ab1_39Arc" = "4159.1",
         "Ab1_42Arc" = "4442.6") %>%
  mutate(ratio = Ab1_42Arc/Ab1_38Arc) %>%
  ggplot(aes(x = sizeGroup, y = ratio)) + 
  geom_boxplot() +
  scale_y_log10() +
  theme_bw() +
  labs(x = "Size Group",
       y = "Ratio Ab1-42Arc/Ab1-38Arc")
```

```{r}
sessionInfo()
```

